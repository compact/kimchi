<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: three.extensions.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: three.extensions.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * three.js extensions for KIMCHI.
 * @namespace THREE
 */
/**
 * @class     THREE.Object3D
 * @memberOf  THREE
 */
/**
 * @class     THREE.PerspectiveCamera
 * @memberOf  THREE
 */
/**
 * @class     THREE.Matrix3
 * @memberOf  THREE
 */
/**
 * @class     THREE.Curve
 * @memberOf  THREE
 */

(function ($, THREE) {
	'use strict';

	/**
	 * "Constant" vectors. Take care to not set other variables to these objects
	 *   directly lest their coordinates change (e.g. position or rotation). Clone
	 *   them instead.
	 * @memberOf THREE
	 */
	THREE.unitVectors = {
		'x': new THREE.Vector3(1, 0, 0),
		'y': new THREE.Vector3(0, 1, 0),
		'z': new THREE.Vector3(0, 0, 1),
		'negX': new THREE.Vector3(-1, 0, 0),
		'negY': new THREE.Vector3(0, -1, 0),
		'negZ': new THREE.Vector3(0, 0, -1)
	};



	/**
	 * @param    {THREE.Object3D} object1
	 * @param    {THREE.Object3D} object2
	 * @return   {Number}         The distance between the two objects.
	 * @memberOf THREE.Object3D
	 */
	THREE.Object3D.distance = function (object1, object2) {
		return object1.position.distanceTo(object2.position);
	};

	/**
	 * "Overload" the original function of THREE.Object3D.prototype.add.
	 * @param    {(THREE.Object3D|Array)} param
	 *   Either an Object3D or an array of Object3Ds to be added.
	 * @function
	 * @memberOf THREE.Object3D
	 */
	THREE.Object3D.prototype.add = (function () {
		var addSingle = THREE.Object3D.prototype.add;
		return function (param) {
			var self = this;

			if (Object.prototype.toString.call(param) === '[object Array]') { // add multiple Object3Ds
				_.forEach(param, function (object) {
					self.add(object);
				});
			} else { // add a single Object3D
				addSingle.call(self, param);
			}
		};
	}());

	/**
	 * Revolve around the given world axis. TODO provide a translation
	 *   vector for cases where the world axis doesn't pass through the origin
	 * @param    {THREE.Vector3} worldAxis Not local based on the object, but
	 *                                     but global in the world.
	 * @param    {Number}        angle     In Radians.
	 * @function
	 * @memberOf THREE.Object3D
	 */
	THREE.Object3D.prototype.orbit = (function () {
		var sin, cos, x, y, z, rotationMatrix, scalingMatrix;
		rotationMatrix = new THREE.Matrix3();
		scalingMatrix = new THREE.Matrix3();

		return function (worldAxis, angle) {
			sin = Math.sin(angle);
			cos = Math.cos(angle);
			worldAxis = worldAxis.normalize();
			x = worldAxis.x;
			y = worldAxis.y;
			z = worldAxis.z;

			scalingMatrix.set( // TODO
				1, 0, 0,
				0, 2, 0,
				0, 0, 1
			);
			rotationMatrix.set( // http://en.wikipedia.org/wiki/Rotation_matrix
				cos + x * x * (1 - cos),
				x * y * (1 - cos) - z * sin,
				x * z * (1 - cos) + y * sin,
				y * x * (1 - cos) + z * sin,
				cos + y * y * (1 - cos),
				y * z * (1 - cos) - x * sin,
				z * x * (1 - cos) - y * sin,
				z * y * (1 - cos) + x * sin,
				cos + z * z * (1 - cos)
			);
			this.position
				.applyMatrix3(scalingMatrix)
				.applyMatrix3(rotationMatrix)
				.applyMatrix3(scalingMatrix.getInverse());
		};
	}());



	/**
	 * Update the camera given dimensions.
	 * @param    {Number} width
	 * @param    {Number} height
	 * @memberOf THREE.PerspectiveCamera
	 */
	THREE.PerspectiveCamera.prototype.update = function (width, height) {
		this.aspect = width / height;
		this.updateProjectionMatrix();
	};



	/**
	 * We overwrite getInverse() because the original function also sets this and
	 *   requires a Matrix4.
	 * @returns  {Matrix3} The inverse matrix.
	 * @function
	 * @memberOf THREE.Matrix3
	 */
	THREE.Matrix3.prototype.getInverse = (function () {
		var determinant, e, inverse = new THREE.Matrix3();

		return function () {
			determinant = this.determinant();
			e = this.elements;

			if (determinant === 0) {
				throw new Error('Matrix3.getInverse(): Matrix not invertible.');
			}

			inverse.set(
				e[4] * e[8] - e[5] * e[7],
				e[2] * e[7] - e[1] * e[8],
				e[1] * e[5] - e[2] * e[4],
				e[5] * e[6] - e[3] * e[8],
				e[0] * e[8] - e[2] * e[6],
				e[2] * e[3] - e[0] * e[5],
				e[3] * e[7] - e[4] * e[6],
				e[1] * e[6] - e[0] * e[7],
				e[0] * e[4] - e[1] * e[3]
			);

			return inverse.multiplyScalar(1 / determinant);
		};
	}());



	/**
	 * For this Curve, create a Line which can be added to a scene. Based on
	 *   http://mrdoob.github.io/three.js/examples/webgl_geometry_shapes.html
	 * @param    {Object}      options
	 * &lt;br>      position:     THREE.Vector3.
	 * &lt;br>      rotation:     THREE.Euler.
	 * &lt;br>      color:        Hexadecimal.
	 * &lt;br>      opacity:      Number.
	 * &lt;br>      lineSegments: Number of line segments to make up the Line.
	 * &lt;br>      scale:        THREE.Vector3.
	 * @returns  {THREE.Line}
	 * @memberOf THREE.Curve
	 */
	THREE.Curve.prototype.createLine = function (options) {
		var curvePath, geometry, line;

		options = _.assign({
			'position': new THREE.Vector3(),
			'rotation': new THREE.Euler(),
			'color': 0x888888,
			'opacity': 1,
			'lineSegments': 360,
			'scale': new THREE.Vector3(1, 1, 1)
		}, options);

		// a CurvePath is needed since it has the createGeometry() functions
		curvePath = new THREE.CurvePath();
		curvePath.add(this);
		geometry = curvePath.createSpacedPointsGeometry(options.lineSegments);

		// create Line
		line = new THREE.Line(geometry, new THREE.LineBasicMaterial({
			'color': options.color,
			'transparent': options.opacity &lt; 1,
			'opacity': options.opacity,
			'linewidth': 1
		}));
		line.position.copy(options.position);
		line.rotation.copy(options.rotation);
		line.scale = options.scale;
		return line;
	};
}(jQuery, THREE));</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-KIMCHI.html">KIMCHI</a></li></ul><h3>Classes</h3><ul><li><a href="module-KIMCHI.space.Body.html">Body</a></li><li><a href="THREE.Controls.html">Controls</a></li><li><a href="THREE.Curve.html">Curve</a></li><li><a href="THREE.Matrix3.html">Matrix3</a></li><li><a href="THREE.Object3D.html">Object3D</a></li><li><a href="THREE.PerspectiveCamera.html">PerspectiveCamera</a></li><li><a href="THREE.Stars.html">Stars</a></li></ul><h3>Namespaces</h3><ul><li><a href="Date.html">Date</a></li><li><a href="Math.html">Math</a></li><li><a href="module-KIMCHI.config.html">config</a></li><li><a href="module-KIMCHI.flight.html">flight</a></li><li><a href="module-KIMCHI.pointerLock.html">pointerLock</a></li><li><a href="module-KIMCHI.space.html">space</a></li><li><a href="THREE.html">THREE</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Fri Aug 30 2013 00:09:32 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
